
5.1 The Configuration State MachineWe do not simply "fire and forget" configuration. Every configuration request (Intent) goes through a strict lifecycle stored in the PostgreSQL database.StateDescriptionWho Triggers?INTENT_DRAFTUser is building the config in the UI. Not yet validated.UIINTENT_PENDINGUser clicked "Deploy." Validation passed. Queued for Orchestrator.API GatewayODL_PUSHEDPayload successfully sent to ODL RestCONF API (HTTP 200).OrchestratorDEVICE_ACKODL confirms device received the config (NETCONF OK / gNMI Set Response).ODL (Async)SYNCEDUse "Read-Your-Writes" check: ODL Operational store matches Config store.Orchestrator (Polling)ERRORAny failure in the chain (Device unreachable, syntax error). Requires manual rollback.System5.2 The "Read-Your-Writes" Consistency ModelSince network devices are slow, we cannot assume instant success.Push: Orchestrator pushes config to ODL's Config Datastore.Wait: Orchestrator waits (with exponential backoff).Verify: Orchestrator queries ODL's Operational Datastore.Does Operational match Config?Yes: Mark Database state as SYNCED.No: Mark Database state as OUT_OF_SYNC or ERROR.5.3 The Telemetry Data Flow (Fast Path)Telemetry does not go through the SQL Database. It follows a "Hot Storage" path.Source: SONiC Switch streams interface_counters via gNMI Dial-Out.Ingest: ODL gNMI Plugin receives the stream.Bypass: ODL pushes raw Protobuf/JSON to Kafka Topic telemetry-raw. (It does not write high-frequency stats to MD-SAL to avoid GC pauses).Process: Telemetry Service (Go) consumes Kafka, enriches with hostname (from Inventory), and writes to InfluxDB/Prometheus.View: UI queries InfluxDB directly (via API Gateway) for graphs.
